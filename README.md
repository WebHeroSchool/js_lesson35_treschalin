# **JavaScript Best Practice Guide**

## <a name='toc'>**Содержание**</a>

1. [Объявление переменных](#variables)
2. [Операторы сравнения и равенства](#compare)
3. [Фигурные скобки](#brace)
4. [Именование](#naming)
5. [Кавычки](#commas)
6. [Объекты](#objects)
7. [Массивы](#arrays)
8. [Функции](#function)
9. [Классы и конструкторы](#class)
10. [Шаблонные строки](#template)

## <a name='variables'>**Объявление переменных.**</a>

### Избегайте var.

- Используйте **_const_** для объявления переменных. Это гарантирует, что вы не сможете переопределять значения, т.к. это может привести к ошибкам и к усложнению понимания кода.

_Плохо:_

```js
var a = 1;
var b = 2;
```

_Хорошо:_

```js
const a = 1;
const b = 2;
```

- Если вам необходимо переопределять значения, то используйте **_let_**.

_Плохо:_

```js
var count = 1;
if (true) {
  count += 1;
}
```

_Хорошо:_

```js
let count = 1;
if (true) {
  count += 1;
}
```

- Помните, что у **_let_** и **_const_** блочная область видимости. const и let существуют только в том блоке, в котором они определены.

```js
{
  let a = 1;
  const b = 1;
}
console.log(a); // ReferenceError
console.log(b); // ReferenceError
```

[К содержанию](#toc)

## <a name='compare'>**Операторы сравнения и равенства.**</a>

Используйте **===** и **!==** вместо **==** и **!=**.
Использование обычного сравнения **==** может вызывать проблемы. Например, оно не отличает **0** от **false**:

```js
alert(0 == false); // true
```

Та же проблема с пустой строкой:

```js
alert("" == false); // true
```

Это происходит из-за того, что операнды разных типов преобразуются оператором **==** к числу. В итоге, и пустая строка, и **false** становятся нулём.

Оператор строгого равенства **===** проверяет равенство без приведения типов.

Другими словами, если **a** и **b** имеют разные типы, то проверка **a === b** немедленно возвращает **false** без попытки их преобразования.

Давайте проверим:

```js
alert(0 === false); // false, так как сравниваются разные типы
```

Ещё есть оператор строгого неравенства **!==**, аналогичный **!=**.

Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше мест для ошибок.

[К содержанию](#toc)

## <a name='brace'>**Фигурные скобки.**</a>

Ставте открывающуюся скобку на той же строке. Перед скобкой – пробел.

_Плохо:_

```js
for (let key in car) {
  console.log(key + " : " + car[key]);
}
```

_Хорошо:_

```js
for (let key in car) {
  console.log(key + " : " + car[key]);
}
```

## <a name='naming'>**Именование.**</a>

Используйте **camelCase** для именования объектов, функций экземпляров.

_Плохо:_

```js
const OBJEcttsssss = {};
const this_is_my_object = {};
function c() {}
```

_Хорошо:_

```js
const thisIsMyObject = {};
function thisIsMyFunction() {}
```

Используйте **PascalCase** только для именования конструкторов и классов.

_Плохо:_

```js
function user(options) {
  this.name = options.name;
}

const bad = new user({
  name: "nope"
});
```

_Хорошо:_

```js
class User {
  constructor(options) {
    this.name = options.name;
  }
}

const good = new User({
  name: "yup"
});
```

[К содержанию](#toc)

## <a name='commas'>**Ковычки.**</a>

Предпочтительно использовать одинарные кавычки везде в коде. Двойные кавычки обычно встречаются в HTML-атрибутах, поэтому использование одинарных кавычек помогает избежать проблем при работе с HTML-строками.

_Плохо:_

```js
const username = "Вася";
const city = "Москва";
```

_Хорошо:_

```js
const username = "Вася";
const city = "Москва";
```

[К содержанию](#toc)

## <a name='objects'>**Объекты.**</a>

Для создания объекта используйте фигурные скобки. Не создавайте объекты через конструктор new Object.

_Плохо:_

```js
var item = new Object();
```

_Хорошо:_

```js
var item = {};
```

[К содержанию](#toc)

## <a name='arrays'>**Массивы.**</a>

Для создания массива используйте литеральную нотацию.

_плохо_

```js
const items = new Array();
```

_хорошо_

```js
const items = [];
```

[К содержанию](#toc)

## <a name='function'>**Функции.**</a>

Используйте функциональные выражения вместо объявлений.

Почему? У объявлений функций есть подъём. Это означает, что можно использовать функцию до того, как она определена в файле, но это вредит читабельности и поддержке. Если вы обнаружили, что определение функции настолько большое или сложное, что мешает понимать остальную часть файла, то, возможно, пришло время извлечь его в отдельный модуль. Не забудьте явно назвать функциональное выражение, независимо от того, подразумевается ли имя из содержащейся переменной (такое часто бывает в современных браузерах или при использовании компиляторов, таких как Babel). Это помогает точнее определять место ошибки по стеку вызовов.

_Плохо:_

```js
function foo() {
  // ...
}
```

_Плохо:_

```js
const foo = function() {
  // ...
};
```

_Хорошо:_

```js
// лексическое имя, отличное от вызываемой(-ых) переменной(-ых)
const foo = function uniqueMoreDescriptiveLexicalFoo() {
  // ...
};
```

[К содержанию](#toc)

## <a name='class'>**Классы и конструкторы.**</a>

- Всегда используйте **class**. Избегайте прямых манипуляций с **prototype**.

Почему? Синтаксис **class** является кратким и понятным.

_Плохо:_

```js
function Queue(contents = []) {
  this.queue = [...contents];
}
Queue.prototype.pop = function() {
  const value = this.queue[0];
  this.queue.splice(0, 1);
  return value;
};
```

_Хорошо:_

```js
class Queue {
  constructor(contents = []) {
    this.queue = [...contents];
  }
  pop() {
    const value = this.queue[0];
    this.queue.splice(0, 1);
    return value;
  }
}
```

- Используйте **extends** для наследования.

Почему? Это встроенный способ наследовать функциональность прототипа, не нарушая _instanceof_.

_Плохо:_

```js
const inherits = require("inherits");
function PeekableQueue(contents) {
  Queue.apply(this, contents);
}
inherits(PeekableQueue, Queue);
PeekableQueue.prototype.peek = function() {
  return this.queue[0];
};
```

_Хорошо:_

```js
class PeekableQueue extends Queue {
  peek() {
    return this.queue[0];
  }
}
```

[К содержанию](#toc)

## <a name='template'>**Шаблонные строки.**</a>

Используйте шаблонные строки (выделенные с помощью `), а не сложную конкатенацию строк, особенно если задействованы несколько строковых литералов. Строки-шаблоны могут охватывать несколько строк.

_Плохо:_

```js
function sayHi(name) {
  return "How are you, " + name + "?";
}
```

_Плохо:_

```js
function sayHi(name) {
  return ["How are you, ", name, "?"].join();
}
```

_Плохо:_

```js
function sayHi(name) {
  return `How are you, ${name}?`;
}
```

_Хорошо:_

```js
function sayHi(name) {
  return `How are you, ${name}?`;
}
```

**Это сокращает код и повышает его удобочитаемость.**

[К содержанию](#toc)
